# 타입스크립트와 자바스크립트의 관계
> 타입스크립트는 문법적으로 자바스크립트의 상위집합입니다.

문법의 유효성과 동작의 이슈는 독립적인 문제입니다. 타입스크립트는 .ts와 .tsx 확장자를 사용하며 .js와 .jsx 확장자를 가진 파일과 완벽하게 호환됩니다. 이는 자바스크립트를 타입스크립트로 마이그레이션하는 데 엄청난 이점이 있습니다.

모든 `자바스크립트는 타입스크립트다`는 명제는 참이지만, 모든 타입스크립트는 자바스크립트가 아닙니다. 그 이유는 타입스크립트가 타입을 명시하는 추가적인 문법을 갖기 때문이죠.
```js
const greet = (who: string) => {
  console.log(`Hello, ${who}!!`);
}
```
이 코드는 자바스크립트를 구동하는 노드나 브라우저에서 실행하는 경우 에러(`SyntaxError: Unexpected token :`)가 발생합니다. 앞서 사용한 `: string`이 타입스크립트에서 사용하는 구문이기 때문에, 이 **타입 구문**을 사용하는 순간부터 자바스크립트는 타입스크립트 영역으로 들어갑니다.

타입스크립트는 컴파일러를 가지고 있습니다. 이 컴파일러는 기본적이 자바스크립트 프로그램에도 유용하죠. 가령 아래와 같은 코드가 있습니다.
```js
let city = 'new city';
console.log(city.toUppercase());
```

이 코드는 에러(`TypeError: city.toUppercase is not a function`)가 발생하죠. 그러나 타입스크립트의 **타입 체커**는 문제점을 찾아냅니다.
```js
let city = 'new city';
console.log(city.toUppercase());

// Property 'toUppercase' does not exist on type '"new city"'. Did you mean 'toUpperCase'?
```

변수의 타입을 아렬주지 않아도 타입스크립트는 **초깃값**으로부터 타입을 **추론**합니다. 이 `타입 추론`은 타입스크립트에서 매우 중요하죠. 타입 시스템의 목표 중 하나는 `런타임에 오류를 발생시킬 코드를 미리 찾는` 것입니다. 그러나 타입 체커가 모든 오류를 찾아내진 않습니다. 또한 오류가 발생하지 않아도 의도와 다르게 동작하는 코드도 있죠.

자바스크립트는 선언되지 않은 프로퍼티에 접근할 경우 이를 생성하고 undefined를 반환합니다. 그에 반면 타입스크립트는 타입 구문이 없어도 오류를 찾아내죠. 그러나 이 오류는 명확하지 않습니다. 이를 더 확실하게 하려면 타입 구문을 추가해야 하죠.

이 행위가 `의도를 명확히`해서 타입스크립트가 잠재적 문제점을 찾을 수 있게 하는 것입니다. 타입 구문 없이 배열 안에 오타를 냈을 경우, 오류가 되지 않았을 테지만 타입 구문을 추가하면 이를 오류로서 인지할 수 있는 것이죠.

타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 `모델링`합니다. 단순히 런타임 동작을 모델링하는 것이 아니라 의도하지 않은 코드가 오류를 발생시킬 수 있다는 것까지 고려하죠.

그러나 타입스크립트의 타입 시스템이 정적 타입의 정확성을 보장해주진 않습니다. 정리하자면, 아래와 같습니다.
1. 타입스크립트는 자바스크립트의 상위집합으로서 별도의 문법을 가진 유요하지 않은 자바스크립트 프로그램입니다. 
2. 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있으므로 런타임 오류를 발생시키는 코드를 찾아낼 수 있지만 모든 오류를 찾아내진 못합니다. 타입 체커를 통과하면서도 런타임 오류를 발생시키는 코드는 충분히 많거든요.
3. 타입스크립트의 타입 시스템은 자바스크립트에서 허용되는 것을 문제삼기도 합니다. 이러한 문법의 엄격함은 취향차이니 우열을 가릴 수 없죠.